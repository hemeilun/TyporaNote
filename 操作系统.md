# 操作系统

<br/>

## （一）绪论

<br/>

### 1.概念，功能和目标

<br/>

#### （1）概念

<br/>

概念：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和分配，以提供给用户和其他软件方便的接口和环境，他是计算机系统中最基本的系统软件。

详细：

- 负责管理协调硬件，软件等计算机资源的工作
- 为上层的应用程序，用户提供简单易用的服务
- 操作系统是系统软件，而不是硬件

<br/><br/><br/><br/>

#### （2）功能和目标

<br/>

分三种情况：

1）作为系统资源的管理者

2）作为用户与计算机硬件之间的接口

3）作为最接近硬件的层次

<br/><br/>

第一种情况：作为系统资源的管理者

提供的功能：

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

目标：

安全，高效

<br/>

示例：

用QQ和朋友视频聊天：

1）在文件夹中找到QQ安装的位置；在文件夹中找到文件的位置（文件管理）

2）双击QQ.exe；需要把程序的相关数据放入内存（存储器管理）

3）QQ程序正常运行；对应的进程被处理机处理（处理机管理）

4）开始和朋友视屏聊天；需要将摄像头设备分配给进程（设备管理）

<br/><br/>

第二种情况：作为用户与计算机之间的接口

提供的功能：

- 命令接口：允许用户直接使用的

  包括：

  联机命令接口：用户说一句，系统做一句。比如：在命令行输入命令，打出一段一个回车一个结果

  脱机命令接口：用户说一堆，系统做一堆。比如：在windows中的*.bat文件，直接执行就会将内部内容一行一行全部执行

- 程序接口：只允许用户通过程序间接使用的，由一组 **系统调用** 组成（系统调用：指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务）（程序接口=系统调用）

- GUI：图形处理界面，现代操作系统中最流行的图形用户接口

目标：

方便用户使用

<br/><br/>

第三种情况：最为最接近硬件的层次

功能和目标：

- 实现对硬件的扩展

注：

- 没有任何软件支持的计算机成为裸机，在裸机上安装操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能上更强，使用更方便的机器
- 通常把覆盖了软件的机器称为扩展机器，又称之为虚拟机

<br/>

示例：

裸机就是木材，操作系统就是一个木匠，他可以将这些木材变为椅子，桌子给人使用

<br/><br/><br/><br/>

### 2.特征

<br/>

有四个特征：并发，共享，虚拟，异步

注：

- 并发和共享是两个最基本的特征，二者互为存在条件
- 没有并发性就谈不上虚拟性
- 只用系统拥有并发性，才可能导致异步性

<br/><br/>

**并发**

<br/>

定义：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时使用的，但在微观上是交替发生的。

并行：指两个或多个事件在同一时刻同时发生。不论是在微观还是在宏观都是同时发生。

<br/>

操作系统的并发性：指计算机系统中同时存在着多个运行着的程序

一个单核CPU同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行。在外表看来是在一起执行，但内部在一个时刻只有一个程序在执行，只是交替速度比较快，人感受不到延迟。

<br/>

示例：

有两个人都是在一天内同时与两个人约会

并行：有一个人，同时和两个人一起约会

并发：另一个人，在8:00~9:00与一个人约会，在9:00~10:00与另一个人约会，在10:00~11:00再与第一个人约会，在11:00~12:00再与第二个人约会

<br/><br/><br/>

**共享**

<br/>

定义：资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用

共享性：指系统中的资源可供内存中多个并发执行地进程同时使用

<br/>

两种资源共享方式：

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程同时使用，但一个时间段内只允许一个进程访问资源
- 同步共享方式：系统中的某些资源，允许在一个时间段内多个进程”同时“对他们进行访问

所谓”同时“往往是宏观上的，而在微观上，这些进程可能是交替地对该资源及逆行访问。

<br/>

示例：

互斥共享方式：在视频通话时，同一时间内摄像头只能分配给其中一个进程

同时共享方式：QQ发送A文件，微信同时发送B文件。宏观上看两边同时占用硬盘发送文件，而微观上，两个进程是交替着访问硬盘。

<br/><br/><br/>

**虚拟**

<br/>

定义：把一个物理上的实体变为若干逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物是用户感受到的

<br/>

两种技术：空分复用技术和时分复用技术

示例：

空分复用技术：电脑内存是4GB，游戏GTA5运行时需要4GB内存，QQ需要256MB内存，微信需要256MB内存，而这三个应用可以同时使用内存大于4GB

时分复用技术：单核CPU执行多个程序，好像是同时执行

<br/><br/><br/>

异步

<br/>

定义：在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。

<br/>

示例：

程序A和B，都需要使用资源C才能完成任务，A，B都需要使用3次该资源，资源只用一份，每次使用完都要重新竞争。假如A先使用该资源，B就需要等待，A使用完不确定下一个是谁使用，所以A进程或B进程对该资源的使用难以一贯到底，A，B就是异步执行。

<br/><br/><br/><br/>

### 3.操作系统的发展与分类

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys1.png" alt="image-20211124155451147" style="zoom:67%;" />

<br/><br/>

**手工操作阶段**

<br/>

由人制作纸带（超慢） —>   输入机器读取纸带（慢） —>  处理机进行处理（快）  —>  输出机器打印纸带（慢） —>  人读取纸带（超慢）

主要缺点：用户独占主机，人机速度矛盾严重，资源利用率低

<br/><br/>

**批处理阶段——单道批处理系统**

<br/>

由人制作纸带 —>   输入机器读取纸带 —>  **外围机数据录入磁带** —>  处理机进行处理  —>  **数据保存到磁带** —> 输出机器打印纸带 —>  人读取纸带

主要优点：缓解了一定程度的人机矛盾，资源利用率有所提升

主要缺点：内存中仅能由一道程序运行，只有改进程运行结束才能调入下一道程序。CPU有大量时间是在空闲等待I/O完成。资源利用率依然很低

注：磁带的输出和输入到磁带是由监督程序负责，这个监督程序就是后续操作系统的雏形

<br/><br/>

**批处理阶段——多道批处理系统**

<br/>

过程与单道批处理系统相同，只是磁带输出到处理机时不是输入一个程序，而是多个程序

主要优点：多道程序并发执行，共享计算机资源。资源利用率大大提升，CPU和其他资源保持”忙碌“状态，系统吞吐量大

主要缺点：用户响应时间长，没有人机交互功能（用户提交自己作业之后只能等待计算机处理完成不能控制自己的作业执行）

注：这个阶段操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的执行，各个程序并发执行

<br/>

单道与多道对比：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys2.png" alt="image-20211124161749151" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys4.png" alt="image-20211124161955652" style="zoom:67%;" />

<br/><br/>

**分时操作系统**

<br/>

过程：有一台主机轮流向多个程序提供服务

定义：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互

主要优点：用户请求可以被及时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在

主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环为每个用户/作业服务一个时间片，不区分任务的紧急性。

<br/><br/>

**实时操作系统**

<br/>

主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。

实时操作系统的主要特点是：**及时性和可靠性**

<br/>

两种实时操作系统：

- 硬实时系统：必须在绝对严格的规定时间内完成处理，比如：导弹控制系统，自动驾驶系统
- 软实时系统：能够偶尔违反时间约定；比如：12306火车购票系统

<br/><br/>

其他几种操作系统：

网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中的各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。比如：Windows NT就是一种典型的网络操作系统，网站服务器可以使用

分布式操作系统：主要特点是分布性和并行性。各系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由他们并行，协同完成这个任务

个人计算机操作系统：如：Windows 10，HarmonyOS，方便个人使用

<br/><br/>

总结：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys5.png" alt="image-20211124163958873" style="zoom: 80%;" />

<br/><br/><br/><br/>

### 4.操作系统的运行机制和体系结构

<br/>

指令：就是处理机能识别，执行的最基本的任务

<br/>

#### （1）运行机制

<br/>

两种指令：

- 特权指令：一些较为核心，不允许用户程序使用的指令，如：内存清零指令
- 非特权指令：提供给一般用户使用的指令。如：加法指令

<br/>

两种处理机状态：

- 核心态（管态）：此时CPU只能执行非特权指令
- 用户态（目态）：特权指令和非特权指令都可以执行

状态标识：用程序状态字寄存器（PSW）中的某些标志位识别当前处理机处于什么状态。

<br/>

两种程序：

- 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，又可以执行非特权指令，运行在核心态
- 应用程序：为了保证系统能够安全运行，普通应用程序只能执行非特权指令，运行在用户态

<br/><br/><br/><br/>

#### （2）操作系统的内核

<br/>

计算机操作系统的层次结构：

<br/>

![image-20211124165409974](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys7.png)

<br/>

内核：计算机上配置的底层软件，是操作系统最基本，最核心的部分。

<br/>

内核组成部分：

- 时钟管理：实现计时功能
- 中断处理：负责实现中断机制
- 原语：
  - 是一种特殊的程序
  - 处于操作系统的最底层，是最接近硬件的部分
  - 这种程序的运行具有原子性——其执行只能一气呵成，不能中断
  - 运行时间较短，调用频繁
- 对系统资源进行管理的功能：
  - 进程管理
  - 存储器管理
  - 设备管理

注：对资源的管理，有的操作系统不把这些功能归为内核功能。也就是说，不同的操作系统，对内核的划分可能并不一样

<br/><br/><br/><br/>

#### （3）操作系统的体系结构

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys8.png" alt="image-20211124170446461" style="zoom:80%;" />

<br/>

**大内核**

<br/>

上图左边规定的内核范围就是大内核，将操作系统的主要功能模块都作为系统内核，运行在核心态

优点：该性能

缺点：内部代码庞大，结构混乱，难以维护

<br/><br/>

**微内核**

<br/>

上图右边规定的内核范围就是大内核，只把最基本的功能保留在内核

优点：内核功能少，结构清晰，方便维护

缺点：需要频繁地在核心态和用户态之间切断，性能低

<br/><br/><br/><br/>

### 5.中断和异常

<br/>

**中断机制的诞生**

<br/>

在早期计算机采用的是单道批处理系统，这种系统使得计算机的资源存在大量的浪费，为解决此问题，人们发明了操作系统，引入中断机制。中断机制解决了多个进程并发执行，导致进程紊乱的问题。

本质：发生中断就意味着需要操作系统的介入，开展管理工作。

<br/>

示例：

1）单核计算机中存在三个A，B，C进程并发执行，

2）首先A进程占用CPU（CPU处于用户态），一段时间后，CPU收到计时器发出的中断信号，CPU切换为核心态，交给操作系统进行中断处理，操作系统发现A进程的时间片用完，换成B进程执行，CPU切换为用户态；

3）再执行一段时间后，B进程发出系统调用（内中断信号），请求输出，CPU切换为核心态，操作系统对中断进行处理，操作系统发现B进程需要打印，于是让打印机开始工作，B进程暂停运行等待I/O完成，换为C进程执行，切换为用户态；

4）C进程执行一段时间后，I/O完成，设备向CPU发出中断信号，接收到中断后，CPU切换为核心态，操作系统发现B进程I/O操作完成，让B进程恢复运行，切换为用户态；

5）操作完成或时间片到时后，发出中断，切换为核心态，操作系统结束二进程，执行别的进程

<br/><br/>

**中断的概念，特点和作用**

<br/>

概念：中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

<br/>

特点：

- 当发生中断时，CPU立即进入核心态
- 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
- 对于不同的中断信号，会有不同的处理

特点概述：发生了中断，就意味着许哟啊操作系统的接入，开展管理工作。由于曹祖哟系统的管理工作（比如进程切换，分配I/O设备等）需要使用特权命令，因此CPU要从用户态转为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。

<br/><br/>

**用户态和核心态之间的切换**

<br/>

用户态 —> 核心态：只能通过中断这个唯一途径实现

核心态 —> 用户态：执行一个特权命令，将程序状态字（PSW）的标志位设置为用户态

<br/><br/>

**中断的分类：**

<br/>

第一种分类方式：

- 内中断（也称异常，例外，陷入）：信号来源于 **CPU内部**，与当前执行的指令有关
  - 自愿中断——指令中断：比如：系统调用时使用的访管指令（又叫陷入指令，trap指令）
  - 强迫中断：
    - 硬件故障：比如：缺页
    - 软件中断：比如：整数除以0
- 外中断（中断）：信号来源于 CPU外部 ，与当前执行的指令无关
  - 外设请求：比如：I/O设备发来的中断
  - 人工干预：比如：用户强行终止一个进程

<br/>

- 内中断（内部异常）：
  - 陷阱，陷入（trap）：有意而为之的异常，如系统调用
  - 故障（fault）：由错误条件引起的，可能被故障处理程序修复，如：缺页
  - 终止（abort）：不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如：整数除以0
- 外中断：
  - I/O设备请求
  - 人工干预

<br/><br/>

**外中断的处理过程：**

<br/>

1）执行完每个指令后，CPU都要检查当前是否有外部中断信号

2）如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC，各种通用寄存器）

3）根据中断类型转入相应的中断处理程序

4）恢复源程序的CPU环境并退出中断，返回原程序继续向下执行

<br/><br/><br/><br/>

### 6.系统调用

<br/>

定义：系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序使用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

<br/>

**系统调用的作用：**

应用程序可以通过系统调用来请求操作系统中的服务。系统中的各种资源都由操作系统统一管理，因此在应用程序中，凡是与资源有关的操作（如：存储分配，I/O操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统带未完成。这样可以保证系统的稳定性和安全性，防止用户的非法操作。

如果不适用系统调用，比如一个进程在进行打印，由于没有系统调用，另一个进程可以直接同时进行打印，这会导致打印出的结果即为混乱，如果由操作系统进行控制，就可以调节两进程的答打印顺序，使得打印结果有序输出。

<br/><br/>

**系统调用的功能：**

- 设备管理：完成设备的 请求/释放/启动 等功能
- 文件管理：完成文件的 读/写/创建/删除 等功能
- 进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能
- 进程通信：完成进程之间的 消息传递/信号传递 等功能
- 内存管理：完成内存的 分配/回收 等功能

这些功能都需要对系统资源进行管理，对进程的控制，所以需要特殊指令执行操作，于是系统调用的相关处理都需要在核心态下完成

<br/><br/>

**系统调用和库函数的区别：**

系统调用是操作系统向上层提供的接口

有的库函数是对系统调用的进一步封装

当今的编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用



<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys9.png" alt="image-20211125120151303" style="zoom:80%;" />

<br/><br/>

**系统调用背后的过程：**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys10.png" alt="image-20211125120426180" style="zoom: 67%;" />

<br/>

过程：传递系统调用参数 —>  执行陷入指令（用户态） —>  执行系统调用相应服务程序（核心态）—>  返回应用程序

注意：

- 陷入指令是在用户态执行的，执行陷入指令后立即引发一个内中断，从而CPU进入核心态
- 发出系统调用请求是在用户态，而对系统的调用是在核心态下完成的
- 陷入指令是唯一一个只能在用户态执行，而不可在核心态下执行的指令

<br/><br/><br/><br/><br/><br/><br/><br/>

## （二）进程管理核处理机调度

<br/>

### 1.进程与线程

<br/>

#### （1）进程的基本概念

<br/>

##### ① 定义

<br/>

程序段：程序代码放置的位置

数据段：程序运行过程中处理的数据放在数据段内

PCB：进程控制块，系统为每个运行的程序配置的一个数据结构，用来描述进程的各种信息（如：程序代码存放位置）

<br/>

定义：程序段，数据段，PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程。例如：所谓创建进程，实质上就是创建进程实体中PCB；而撤销进程，实质上就是撤销进程实体中的PCB。

注意：PCB是进程的唯一标志

<br/>

从不同的角度，进程可以有不同的定义，比较传统典型的定义有：

- 进程是程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能的程序在数据集合上运行的进程，他是系统进行资源分配和调度的一个独立单位

这几个定义都是强调进程的动态性

<br/>

引入进程实体的概念后，可把进程定义为：

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

注意：严格的说，进程实体和进程并不一样，进程实体是静态的，进程是动态的。不过，除非题目中专门考察二者之间的去呗，否则可以认为进程实体就是进程。因此我们可以说：进程是由数据段，程序段，PCB三部分组成

<br/><br/><br/><br/>

##### ② 组成

<br/>

进程是由PCB，程序段，数据段 三部分组成

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys13.png" alt="image-20211125123545701" style="zoom: 50%;" />

<br/>

PCB的内容：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys11.png" alt="image-20211125123051060" style="zoom: 67%;" />

<br/>

注：

- 当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的ID，用于区分不同的进程（类似于身份证号）
- 当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示程序进行到了哪一句

<br/>

另一种分类：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys12.png" alt="image-20211125123457780" style="zoom:67%;" />

<br/><br/><br/><br/>

##### ③ 组织

<br/>

在一个系统中，通常有数十，数百乃至数千个PCB。为了能对他们更加有效的管理，应当用适当的方式把这些PCB组织起来。

<br/>

进程的组织方式：

- 链接方式：按进程状态将PCB分成多个队列；操作系统持有指向各个队列的指针
- 索引方式：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针

<br/>

链接方式：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys14.png" alt="image-20211125124149710" style="zoom: 50%;" />

<br/>

索引方式：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys15.png" alt="image-20211125124245720" style="zoom:50%;" />

<br/><br/><br/><br/>

##### ④ 特征

<br/>

- **动态性**（最基本的特征）：进程是程序的一次执行过程，是动态的产生，变化和消亡的
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位
- 异步性：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步的问题
- 结构性：每个进程都会配置一个PCB。结构上看，进程是由程序段，数据段，PCB组成

<br/><br/><br/><br/>

#### （2）进程状态

<br/>

进程是程序的一次执行。在这个执行过程中，有时进程正被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对进程的管理，操作系统需要将进程合理地划分为几种状态。

<br/>

进程的三种基本状态：

- 运行态：占有CPU，并在CPU上运行。在单核处理机环境中，每一个时刻最多只有一个进程处于运行状态，在双核处理机中做多就有两个进程处于运行状态
- 就绪态：已经具备运行的条件，但没有空闲的CPU，而展示不能进行。进程拥有了处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
- 阻塞态：又称等待态，因等待某一件事而暂时不能运行。如：等待操作系统分配打印机，等待读磁盘的操作结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。

另外两种状态：

- 创建态：又称新建态，进程正在被创建，操作系统为进程分配资源，初始化PCB
- 终止态：又称结束态，进程正从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opernet.png" alt="image-20211125130228348" style="zoom:67%;" />

<br/>

注：

- 运行态 —> 阻塞态：是一种进程自身做出的主动行为
- 阻塞态 —> 就绪态：不是自身能够控制的，是一种被动行为
- 不能有阻塞态直接转化为运行态，也不能由就绪态直接转化为阻塞态（因为进入阻塞态是进程主动请求的，必须在运行时才可以发出这种请求）

<br/><br/><br/><br/>

#### （3）进程控制

<br/>

定义：对系统中的所有进程实现有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换

简单理解：实现进程状态转换

<br/>

过程：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys16.png" alt="image-20211125215509922" style="zoom: 67%;" />

<br/><br/>

**原语**

<br/>

实现方式：用 **原语** 实现进程控制

原语的特点时：执行时不允许中断，只能一气呵成

原子操作：这种不可被中断的操作

原语采用“关中断方式”和“开中断方式”实现

显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令

<br/>

**进程控制的相关原语**

<br/>

进程控制会导致进程状态的转换。无论哪种原语，要做的事无非三件：

1）更新PCB中的信息（如：修改进程状态标志，将运行环境保存到PCB，从PCb恢复运行环境）

- 所有进程控制原语一定会修改进程状态的标志
- 剥夺当前运行的CPU使用权必然需要保存其运行环境
- 某进程开始运行前必然要恢复其运行环境

2）将PCB插入到合适的队列

3）分配/回收资源

<br/>

无 —>  创建态 —>  就绪态

创建原语：

- 申请空白PCB
- 为新进程分配所需资源
- 初始化PCB
- 将PCB插入就绪队列

引起进程创建的事件：

- 用户登录：分时系统中，用户登录成功，系统就会为其建立一个新的进程
- 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
- 提供服务：用户向操作系统提出某些请求时操作系统会新建一个进程处理该请求
- 应用请求：由用户进程主动请求创建一个子进程

<br/>

就绪态/阻塞态/运行态 —>  终止态 —>  无

撤销原语：

- 从PCB集合中找到终止进程的PCB
- 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
- 终止其所有子进程
- 将该进程拥有的所有资源归还给父进程或操作系统
- 删除PCB

引起进程终止的事件：

- 正常结束
- 异常结束
- 外界干预

<br/>

阻塞原语与唤醒原语（要成对出现）：

阻塞原语：

- 找到要阻塞的进程对应的PCB
- 保护进程运行现场，将PCB状态信息设置为”阻塞态“，暂时停止进程运行
- 将PCB插入相应事件的等待队列

引起进程阻塞的事件：

- 需要等待系统分配某种资源
- 需要等待相互合作的其他进程完成工作

<br/>

唤醒原语：

- 在事件等待队列中找到PCB
- 将PCB从等待队列移除，设置进程为就绪态
- 将PCB插入就绪队列，等待被调度

引起进程唤醒的事件：

- 等待的事件发生

<br/>

运行态  —>  阻塞态/就绪态  

就绪态  —>  运行态

切换原语：

- 将运行环境信息存入PCB
- PCB移入相应队列
- 选择另一个进程执行，并更新其PCB
- 根据PCB恢复新进程所需的运行环境

引起进程切换的事件：

- 当前进程时间片到
- 有优先级更高的进程到达
- 当前进程主动阻塞
- 当前进程终止

<br/><br/><br/><br/>

#### （4）进程通信

<br/>

定义：进程之间的信息交换

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立

为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法：共享存储，消息传递，管道通信

<br/><br/>

**共享存储**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys17.png" alt="image-20211125223549952" style="zoom:67%;" />

<br/>

两个进程对共享空间的访问必须是互斥的（互斥通过操作系统的工具实现）

操作系统只负责提供共享空间和同步互斥工具（如：P，V操作）

<br/>

共享存储有两种方式：

- 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢，限制多，是一种低级通信的方式
- 基于存储区的共享：在内存中画出一块共享存储区，数据的形式，存放的位置都由进程控制，而不是操作系统。相比之下，这种共享存储的方式更快，是一种高级通信的方式

<br/><br/>

**管道通信**

<br/>

管道：指用于连续读写进程的一个共享文件，又叫pipe文件。其实就是在内存中开辟一个大小固定的缓存区

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys18.png" alt="image-20211125224300449" style="zoom:67%;" />

<br/>

注：

- 管道通信只能采用 **半双工通信** ，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道
- 各进程要**互斥**的使用管道
- 数据以字符流的形式写入管道，当管道写满时，写进程的write（）系统调用将被阻塞，等待读进程将数据取走。当读进程将数据都取走后，管道变空，此时读进程的read（）系统调用将被阻塞
- 如果没写满，就不允许读。如果没读空，就不允许写
- 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

<br/><br/>

**消息传递**

<br/>

定义：进程间的数据交换以格式化的消息为单位，进程通过操作系统提供的”发送消息/接收消息“两个原语进行数据交换

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys19.png" alt="image-20211125225219769" style="zoom: 67%;" />

<br/>

消息头包括：发送进程ID，接受进程ID，消息类型，消息长度等格式化的信息（计算机网络中发送的报文就是一种格式化的消息）

<br/>

消息传递有两种方式：

- 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
- 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称为“信箱通信方式”。Eg：计网中的电子邮件

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys21.png" alt="image-20211125225653435" style="zoom:50%;" />

<br/><br/><br/><br/>

#### （5）线程概念与多线程模型

<br/>

定义：可以理解为轻量级进程，线程是一个基本的CPU执行单元，也是程序执行流的最小单位。

引入线程之后，不仅是进程之间可以并发，进程内的个线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务

引入线程后，进程只作为除CPU之外的系统资源的分配单元。如打印机，内存地址都是分配给进程的。

<br/>

引入线程之后，带来的变化

- 资源分配，调度
  - 传统进程机制中，进程是资源分配，调度的基本单位
  - 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
  - 传统进程机制中，只能进程间并发
  - 引入线程后，各线程件也能并发，提高了并发度
- 系统开销
  - 传统的进程间并发，需要切换进程的运行环境，系统开销大
  - 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入进程后，并发所带来的系统开销减小

<br/>

线程的属性：

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID，线程控制块（TCB）
- 线程也有就绪，阻塞，运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程之间共享系统资源，由于共享内存地址，同一进程中的线程间的通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换
- 切换同进程内的进程，系统开销很小；切换进程，系统开销较大

<br/><br/>

**线程的实现方式：**

用户级线程，内核级线程，两者结合

1）用户级线程（ULT）

用户级线程由应用程序通过线程库实现。

所有的线程管理工作都由应用程序负责（包括线程切换）

用户级线程中，线程切换可以在用户态下完成，无需操作系统干预

在用户看来，是有多个线程。但在操作系统的内核看来，并意识不到线程的存在。用户级线程对用户不透明，对操作系统透明

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys22.png" alt="image-20211128175800551" style="zoom: 50%;" />

<br/>

2）内核级线程（KLT）

内核级线程的管理工作由操作系统内核完成。

线程调度，切换等工作都是由内核完成，因此内核线程的切换必须在核心态才能完成

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys23.png" alt="image-20211128180209789" style="zoom:50%;" />

<br/>

3）两者结合

在同时支持用户级线程和内核级线程的系统中，可采用二者结合的方式：将n个用户级线程映射到m个内核级线程上（n>m）

重点：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位

例如：有一个进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个进程。但即使该进程在一个4核处理机的计算机上运行，也最多只能分配到两个核，最多只能有两个用户级线程并行执行

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys24.png" alt="image-20211128180959803" style="zoom:50%;" />

<br/><br/>

**多线程模型**

多对一，一对一，多对多

即在同时支持用户级线程和内核级的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”的问题

1）多对一

定义：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程

优点：用户级线程的切换在用户空间即可完成，不需要到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可再多核处理机上并行运行

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys25.png" alt="image-20211128181719494" style="zoom:50%;" />

<br/>

2）一对一

定义：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同数量的内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行

缺点：一个用户进程会占用多个内核级线程，线程的切换由操作系统内核完成，要切换到核心态，因此线程管理的成本高，开销大

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys26.png" alt="image-20211128182217180" style="zoom:50%;" />

<br/>

3）多对多

定义：n用户及线程映射到m个内核级线程（n>m）。每个用户进程对应m个内核级线程

克服了多对一并发性不高的问题，有克服了一对一中一个用户进程占用太多内核级线程，开销太大的缺点

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys27.png" alt="image-20211128182519896" style="zoom:50%;" />

<br/><br/><br/><br/>

### 2.处理机调度

<br/>

#### （1）基本概念

<br/>

定义：从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

调度的原因：在多道程序系统中，进程的数量往往都是多于处理机的个数，这样不可能同时并行地处理各个进程。

<br/><br/><br/><br/>

#### （2）调度的三个层次

<br/>

##### ① 高级调度

<br/>

定义：按一定的原则从 **外存** 上处于后备队列的作业中挑选一个（或多个）作业，该他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他们获得竞争处理机的权力。

原因：由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规划来决定将作业调入内存的顺序。

注：高级调度是辅存与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题。因此调入需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

<br/><br/>

##### ② 中级调度

<br/>

定义：就是要决定将哪个处于挂起的进程重新调入内存。

引入了虚拟存储技术后，可以暂时不能运行的金册灰姑娘调至外存等待。等它重新具备了运行条件且内存稍有空闲时，再重新调入内存，这么做的目的时提高内存利用率核系统吞吐量。

展示调到外存等待的进程状态为 **挂起状态** ，值得注意的是，**PCB并不会一起调到外存，而是会常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等消息，操作系统通过内存中的PCB来保持对各个进程的监控，管理。被挂起的进程PCB会被放到挂起队列中。

一个进程可能会被多次取出，调入内存，因此中级调度发生的频率要比该机调度更高。

<br/><br/>

##### ③ 低级调度

<br/>

定义：主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度

进程调度的频率很高，一般几十毫秒一次

<br/><br/>

##### ④ 三种调度对比

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys28.png" alt="image-20211128192051526" style="zoom:67%;" />

<br/><br/><br/><br/>

#### （3）补充：进程的挂起状态与七状态模型

<br/>

挂起状态：暂时调到外存等待的进程状态

挂起状态又可以进一步细分为就绪挂起，阻塞挂起量两种状态

注意：

挂起和阻塞的区别，两种状态都是暂时不能获取CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞状态下进程映像还在内存中。

有的操作系统会把就绪挂起，阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起状态进一步细分为多个队列。

<br/><br/><br/><br/>

### 3.进程调度

<br/>

#### （1）时机

<br/>

需要进程切换的情况：

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞（如：等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有更紧急的事等待处理（如：I/O中断）
  - 有更高优先级的进程进入了就绪队列

<br/>

不能进行进程调度与切换的情况：

- 在处理中断的过程中。中断处理复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
- 进程在操作系统内核程序临界区中
- 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如：修改PCB的进程标志状态标志，并把PCB放到相应队列）

<br/>

临界资源：一个时间段内只允许一个进程使用的资源。要求进程之间互斥地访问临界资源

临界区：访问临界资源地那段代码

内核程序临界区：一般用来访问某种内核数据结构的，比如：进程的就绪队列

<br/>

由于内核程序临界区占用资源的特殊性，所以不允许进程调度与切换。

如果还没有退出临界区（未解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此无法顺利及逆行进程调度。

内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此访问内核程序临界区期间不能进行调度和切换。

而对于普通临界区

比如打印机，在打印机完成打印之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU空闲，造成浪费。

普通临界区访问的临界资源不会直接影响到操作系统内核的管理工作。因此在访问普通临界区时可以进行调度和切换。

<br/><br/><br/><br/>

#### （2）切换与过程

<br/>

”狭义的进程调度“与”进程切换“的区别

狭义的进程切换：指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的过程，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指：一个进程让出处理机，由另一个进程占用处理机的过程

广义的进程切换：包括选择一个进程和进程切换两个步骤

<br/>

进程切换的过程主要完成了：

1）对原来运行进程各种数据的保存

2）对新的进程各种数据的恢复（如：程序计数器，程序状态字，各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

<br/>

注意：进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然会导致整个系统的效率较低，是系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少。

<br/><br/><br/><br/>

#### （3）方式

<br/>

非剥夺调度方式：又称非抢占方式，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动请求进入阻塞态。

特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

<br/>

剥夺调度方式：又称抢占方式，当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的金册灰姑娘需要使用处理机，则立即暂停正在执行的过程，将处理机分配给那个更急迫的进程。

特点：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统，实时操作系统

<br/><br/><br/><br/>

### 4.调度算法

<br/>

#### （1）调度算法的评价指标

<br/>

CPU利用率

系统吞吐量

周转时间：包括周转时间，平均周转时间；带权周转时间，平均带权周转时间

等待时间

响应时间

<br/>

##### ① CPU利用率

<br/>

由于早期CPU造价及其昂贵，因此人们希望让CPU尽可能多地工作

CPU利用率：指CPU忙碌时间占总时间地比例

利用率 =  忙碌时间  /  总时间

<br/><br/>

##### ② 系统吞吐量

<br/>

对于计算机来说，希望能用少尽可能的时间处理尽可能多的作业

系统吞吐量：单位时间内完成作业的数量

系统吞吐量 =  总共完成了多少道作业  / 总共用了多少时间

<br/>

比如：某计算机系统用100秒完成了10道作业，则系统吞吐量？

10 /  100 = 0.1道/秒

<br/><br/>

##### ③ 周转时间

<br/>

对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。

周转时间：指从作业被提交到系统开始，到作业完成为止 这段时间间隔

<br/>

包括4个部分：

- 作业从外存后备队列上等待作业调度（高级调度）的时间
- 进程在就绪队列上等待进程调度（低级调度）的时间
- 进程在CPU上执行的时间
- 进程等待I/O操作完成的时间

<br/>

周转时间 =  作业完成的时间 -  作业提交的时间

平均周转时间 = 各作业周转时间之和 /  作业数

注：对于用户来说，更关心自己的单个作业的周转时间；对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值

<br/>

带权周转时间 =  作业周转时间 / 作业实际运行的时间   =   （作业完成的时间 - 作业提交时间）/  作业实际运行的时间

平均带权周转时间 = 各作业带权周转时间之和 /  作业数

注：

- 带权周转时间必然 >= 1
- 带权周转时间和周转时间都是越小越好
- 对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高
- 对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高

<br/><br/>

##### ④ 等待时间

<br/>

计算机的用户希望自己的作业尽可能少的等待处理机

等待时间：指进程/作业处于等待处理机状态时间和，等待时间越长，用户满意度更低

<br/>

对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，所以等待I/O进程的时间不计入等待时间

对于作业来说，不仅要考虑建立进程后的等待时间，还要考虑作业在外存后备队列中（等待创建进程）的时间

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间，当然，也有“平均等待时间”来评测整体性能。

<br/><br/>

##### ⑤ 响应时间

<br/>

对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入一个调试命令）尽早的开始被系统服务，回应。

响应时间：指从用户提交请求到首次产生响应所用的时间。

<br/><br/><br/><br/>

#### （2）调度算法（早期）

<br/>

先来先服务算法（FCFS），短作业优先（SJF），高响应比优先（HRRN）

算法评测均从：算法思想，算法规则，用于作业/进程调度，是否可抢占，优缺点，是否会导致饥饿

饥饿：存在某一进程一直处于等到状态，不被服务

<br/>

##### ① 先来先服务算法（FCFS）

<br/>

算法思想：主要从“公平”的角度考虑

算法规则：按照作业/进程到达的先后顺序进行服务

用于作业/进程调度：用于作业调度，考虑的是哪个作业先到达后备队列；用于进程调度是，考虑是哪个进程先到达就绪队列

是否可抢占：非抢占式算法

优缺点：

- 优点：公平，算法简单
- 缺点：排在长作业（进程）后面的的短作业需要等待很长的时间，带权周转时间很大，对短作业来说体验不好。即，FCFS算法对长作业有利，对短作业不利

是否会导致饥饿：不会

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys29.png" alt="image-20211129205752236" style="zoom:80%;" />

<br/><br/>

##### ② 短作业优先（SJF）

<br/>

算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间

算法规则：最短的作业/进程优先获得服务（”最短“指的是服务时间最短）

用于作业/进程调度：既可用于作业调度，也可用于进程调度。用于进程调度时称为”短进程优先（SPF）算法“

优缺点：

- 优点：”最短的“平均等待时间，平均周转时间
- 缺点：不公平，对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能真正左到短作业优先

是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。如果一直得不到服务，则称为”饿死“

<br/>

**非抢占式：**

<br/>

短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短地作业/进程

当作业间不是同时来的，先来先处理；当多个作业同时处于等待时，服务时间最小的先处理，服务时间相同且最小时，先来先处理

对正在运行的作业不可以打断，不管后来的服务时间更短。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys30.png" alt="image-20211129211434247" style="zoom:67%;" />

<br/><br/>

**抢占式：**

<br/>

最短剩余时间优先算法：每当有进程加入就绪队列时就要进行调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列末。另外，当一个进程完成时，也需要调度。

不管运行的怎么样，只要新来的进程被服务时间更短就抢占

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys31.png" alt="image-20211129211959476" style="zoom: 67%;" />

<br/><br/>

注意几个小细节：

1）如果题目中未特别声明，所提到的”短作业/进程优先算法“默认是非抢占式的

2）很多书上说，SJF调度算法的平均等待时间，平均周转时间最少。

严格来说，这个表述是错误的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间，平均周转时间更少，应该加上一个条件”在所有进程同时可运行时“或者说”所有进程同时到达时“，如果不加上上述条件，则应该说”抢占式的短作业/进程优先调度算法的平均等待时间，平均周转时间更少“

3）虽然严格来说，SJF的平均等待时间，平均周转时间不一定是最少，但相比于其他算法，SJF依然可是获得较少的平均等待时间和平均周转时间

4）如果选择题遇到”SJF调度算法的平均等待时间，平均周转时间最少“的选项，那最好判断其他选项是不是有明显的错误，如果没有更合适的选项，那就选这项

<br/><br/>

##### ③ 高响应比优先（HRRN）

<br/>

算法思想：要综合考虑作业/进程的等待时间和要切服务的时间

算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务

响应比 =  （等待时间 + 要求服务时间） /  要求服务时间

用于作业/进程调度：既可用于作业调度，也可用于进程调度

是否可抢占：非抢占式算法。因此只有当当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比

优缺点：

- 优点：综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业的饥饿问题

是否会导致饥饿：不会

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys32.png" alt="image-20211129214214637" style="zoom:80%;" />

<br/><br/>

##### ④ 三种算法总结

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys33.png" alt="image-20211129214340362" style="zoom:80%;" />

<br/>

注：这几种算法主要关心对用户的公平性，平均周转时间，平均等待时间等评价系统整体性能的指标，但是不关心”响应时间“，也并不区分任务的紧急程度，因此对于用户来说交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在扮演者很重要的角色。

<br/><br/><br/><br/>

#### （3）调度算法（新）

<br/>

时间片轮转，优先级调度，多级反馈队列

<br/>

##### ① 时间片轮转

<br/>

算法思想：公平地，轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应

算法规则：按照各进程到达就绪队列的顺序，轮流让每个进程执行一个时间片。若进程未哎一个时间片内完成，则剥夺处理机，将进程重新放到就绪队列尾重新排队

用于作业/进程调度：用于进程调度（只有作业放到内存中建立相应的进程后，才能被分配处理机时间片）

是否可抢占：若进程未能在时间片内完成，将被剥夺处理机使用权，因此时间片轮转调度属于抢占式算法。由时钟装置发出时钟中断来通知CPU时间片已到。

优缺点：

- 优点：公平，响应快，适用于分时操作系统
- 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度

是否会饥饿：不会

补充：如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。如果时间片太小，由于进程调度，切换是有时间代价的（保存，恢复运行环境），时间片太小会导致进程切换频繁，系统会花费大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。

<br/>

**当时间片大小为2时：**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys34.png" alt="image-20211129224645770" style="zoom:80%;" />

![image-20211129224820360](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys35.png)

![image-20211129224854663](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys36.png)

![image-20211129224935015](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys37.png)

<br/><br/>

**当时间片大小为5：**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys38.png" alt="image-20211129225117629" style="zoom:67%;" />

<br/><br/>

##### ② 优先级调度算法

<br/>

算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

算法规则：调度时选择优先级最高的作业/进程

用于作业/进程调度：即可用于作业调度，也可用于进程调度。甚至，还会用于后面学些的I/O调度中

是否可抢占：抢占式，非抢占式都有。做题时的区别：非抢占式只需要在进程主动放弃处理机式会进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。

优缺点：

- 优点：用优先级区分紧急程度，重要程度，适用于实时操作系统，可灵活的调整对各种作业/进程的偏好程度。
- 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿

是否会导致饥饿：会

<br/>

补充：

就绪队列未必只有一个，可以按照不同的优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置

根据优先级是否可以改变，可将优先级分为静态优先级和动态优先级两种。

静态优先级：创建进程时确定，之后一直不变

动态优先级：创建进程时有一个初始值，之后会动态地调整优先级。

<br/>

如何合理设置各类进程的优先级：

通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程（或称I/O繁忙型进程）（I/O设备和CPU可以并行共工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早投入工作，则资源利用率，系统吞吐量都会得到提升）

注：与I/O进程相对的是计算型进程（或称CPU繁忙进程）

如果是动态优先级，什么时候调整：

可以从追求公平，提升资源利用率等角度考虑。

如果进程在就绪队列中等待了很长时间，则可以适当提高其优先级。如果某进程在处理机上运行了很长时间，则可适当降低其优先级。如果发现一个进程频繁地I/O操作，则可适当提升其优先级。

<br/>

**非抢占式：**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys39.png" alt="image-20211129231116042" style="zoom:80%;" />

<br/><br/>

**抢占式：**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys41.png" alt="image-20211129231347307" style="zoom:67%;" />

<br/><br/>

##### ③ 多级反馈调度算法

<br/>

算法思想：对其他调度算法地折中权衡

算法规则：

1）设置多级就绪序列，各级队列优先级从高到低，时间片从小到大

2）新进程到达时进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还没有结束，则进程进入下一级队列队尾。如果此时已经是最下级的队列，则重新放回该队列队尾

3）只有K级队列为空时，才会K+1级对头的进程分配时间片

用于作业/进程调度：用于进程调度

是否可抢占：抢占式算法。在k级队列的进程运行过程中，若更高级的队列（1~k-1级）中进入一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。

优缺点：

- 优点：对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到响应（RR的优点）；短进程只用比较少的时间就可以完成（SPF的优点）；不必实习那估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程地偏好程度，比如CPU密集型进程，I/O密集型进程（拓展：可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高的优先级）

是否会导致饥饿：会

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys42.png" alt="image-20211130141654627" style="zoom:80%;" />

<br/>

过程：

1）P1在0时刻到达，进入第1级队列，运行1个时间片，中断进入第2级队列

2）P2在1时刻到达，进入1级队列，运行1个时间片，中断进入第2级队列，在P1的后面

3）P1运行两个时间片，到达3时刻，中断进入第3级队列，P2运行1个时间片后

4）在5时刻，P3到达，进入第1级队列，由于队列优先级更高，中断P2并运行P3，P2返回第2级队列

5）在6时刻，P3完成，中断。运行P2。

6）在7时刻，P2运行两个时间片，P2完成，运行P1

7）无其他进程，P1一直运行到结束

<br/><br/>

##### ④ 三种算法总结

<br/>

![image-20211130142544856](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys43.png)

<br/><br/><br/><br/>

### 5.进程同步与互斥

<br/>

#### （1）概述

<br/>

##### ① 同步

<br/>

同步：又称直接制约关系，是指完成某种任务而建立的两个或多个进程在某些位置上为了协调他们的工作次序而产生的制约关系。进程之间的直接制约关系是源于他们的相互合作。

同步所讨论的内容：如何解决异步性问题带来的执行紊乱。

异步性：各并发执行的进程以各自独立的，不可预知的速度向前推进

示例：读进程和写进程的并发执行，由于并发性必然导致异步性，因此“写数据”和”读数据“的两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据—>读数据”的顺序来执行。由此这种制约关系就是进程同步。

<br/><br/>

##### ② 互斥

<br/>

进程互斥：指当一个进程访问某些临界资源时，另一个想要访问该临界资源地进程必须等待。当前访问临界资源地进程访问结束后，另一个进程才能去访问。

原因：由于进程的并发需要共享的支持。各并发执行的进程不可避免地需要共享一些资源，但是这些进程又不能在同一时间都利用这些资源，由此需要进程互斥，保证在同一时刻只有一个进程在访问资源。

<br/>

两种资源共享方式：

- 互斥共享方式：系统的某些资源，虽然可以提供给许多各进程使用，但是在一个时间段内只允许一个进程访问资源
- 同时共享方式：系统中的某些资源，允许在一个时间段有多个进程“同时”对他们进行访问，微观上，在同一时刻仍然只有一个进程在访问该资源

<br/>

临界资源：一个时间段内只允许一个进程使用的资源。许多物理设备（如摄像头，打印机）都属于临界资源。此外还有许多变量，数据，内存缓冲区都属于临界资源。

互斥：又称间接制约关系。

注：对于临界资源的访问，必须互斥地进行。

<br/>

**对临界资源访问地四个部分**

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys44.png" alt="image-20211130145158091" style="zoom: 80%;" />

<br/>

注意：

- 临界区是进程中访问临界资源地代码段
- 进入区和退出区时负责实现互斥的代码段

<br/>

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：

1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区

2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待

3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）

4）让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

<br/><br/><br/><br/>

#### （2）进程互斥的软件实现方法

<br/>

单标志法，双标志先检查，双标志后检查，Peterson算法

<br/>

##### ① 单标志法

<br/>

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说 每个进程进入临界区的权限只能被另一个进程赋予

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys45.png" alt="image-20211130200149589" style="zoom:67%;" />

<br/>

说明：

turn的初值为0，即刚开始只允许0号进入临界区。

若P1先上处理机进行处理，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0在处理机运行。

代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区时即使切换回P1也会卡在⑤。

只有P0在退出区将turn改为1后，P1才能进入临界区

<br/>

存在的问题：turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程访问临界区后，才会修改turn的值。也就是说，对于临界区的访问一定是按照P0 —>  P1 —>  P0 —> ·······  这样轮流访问。这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。

因此，单标志法存在的主要问题是：违背“空闲让进”原则

<br/><br/>

##### ② 双标志先检查法

<br/>

算法思想：设置一个布尔类型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如:"flag[0]=true"意味着0号进程P0想进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]改为true，之后开始访问临界区。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys46.png" alt="image-20211130201825381" style="zoom:80%;" />

<br/>

过程：两进程是平等的关系，假如P1先进行，因为flag[0] != true，所以P0没有使用临界区，P1可以进入临界区，将flag[1]改为true，表示自己已占用临界区，这时P1在进行后发现flag[1] = ture，就一直循环等待P1完成，P1访问完临界区后，在退出区将flag[1]改为false，这时P0可以进入访问临界区。

<br/>

存在的问题：若按照①⑤②⑥③⑦....运行，P0和P1将会同时访问临界区。

问题在于，进入去“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换

因此，双标志先检查法的主要问题是：违反“忙则等待”原则

<br/><br/>

##### ③ 双标志后检查法

<br/>

算法思想：双标志前检查法的改版，前一个算法的问题在于是“先检查，后上锁”，但是这两个操作又无法一气呵成，因此导致了两进程同时进入临界区的问题。因此，人们又想到先上锁后检查的方法。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys47.png" alt="image-20211130203003205" style="zoom:80%;" />

<br/>

过程：和前面算法过程非常类似，只是先进行上锁，后检查。

<br/>

存在的问题：若按照①⑤②⑥....的顺序执行，P0和P1都无法进入临界区

因此，双标志后检查法虽然解决了忙则等待的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。

<br/><br/>

##### ④ Peterson算法

<br/>

算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后都无法进入临界区。Gray L.Peterson想到了一种方法，如果双方都想要进入临界区，那可以让进程尝试孔融让梨，主动让对方先使用临界区。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys48.png" alt="image-20211130203721152" style="zoom:67%;" />

<br/>

过程：两进程处于同等地位，当P1先进入时，将flag[1]设置为1，假如此时时间片到发生中断，P2进入，设置flag[1] = true，将turn改为0，此时由于flag[0] = true（发现P1也在竞争，所以让给他），trun = 1，所以P1进程处于循环状态，到时间片到后，进入P0，由于flag[1] = true，trun = 1，过循环进入临界区，再进入退出区后将flag[0]改为false（表示停止使用缓冲区），由此看两进程同时发生竞争时，优先后来的进程进入。

<br/>

进入区：

- 主动争取
- 主动谦让
- 检查对方是否也想使用，且最后一次是不是自己说了客气话

<br/>

优点与问题：Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进，忙则等待，有限等待三个原则。但是依然未遵循让全等待的原则。

相较于前三种算法，Peterson是最好的，但依然不够好。

<br/><br/><br/><br/>

#### （3）进程互斥的硬件实现方法

<br/>

中断屏蔽方法，TestAndSet（TS指令/TSL指令），Swap指令（XCHG）

<br/>

##### ① 中断屏蔽算法

<br/>

利用“开关中断指令“实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许中断，也不能发生两个同时访问临界区的情况）

<br/>

关中断 —>  临界区  —>  开中断

关中断后即不允许当前进程被中断，也必然不会发生进程切换

直到当前进程访问完临界区，再执行开中断指令，才有可能又别的进程上处理机并访问临界区

<br/>

优点：简单，高效

缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开关指令只能在内核态，这组指令直接给用户用会很危险）

<br/><br/>

##### ② TestAndSet（TS指令/TSL指令）

<br/>

TSL指令使用硬件实现的，执行的过程不允许被中断，只能一气呵成

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys49.png" alt="image-20211130221512975" style="zoom:67%;" />

<br/>

过程：两进程优先级相同，初始时均为false，假如P1先进入，首先将lock的false赋值给old，再将lock更改为true，表示已上锁，当old返回后，while循环判断开始没有上锁，就会进入临界区，此时P2进入，由于P0已将lock改为true，所以先将true赋值给old，再将lock改为true，返回后发现已经上锁了，就会一直处于循环中，直到P1退出临界区，将lock改为false，P0才可以进入。

<br/>

相比软件实现的方式，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作。

优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境

缺点：不满足让全等待原则，展示无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

<br/><br/>

##### ③ Swap指令

<br/>

有的地方也叫Exchange指令，或简称XCHG

Swap指令：用硬件实现的，执行的过程不允许被中断，只能一气呵成。

<br/>

![image-20211202134040865](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys50.png)

<br/>

逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变化量上），再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前并没有别的进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等

<br/><br/><br/><br/><br/>

#### （4）信号量机制

<br/>

用户可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥，进程同步

信号量：是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以使用一个信号量来表示某种系统资源的数量。比如：一个系统有一台打印机，就可以设置一个初值为1的信号量

<br/>

原语：一种特殊的程序段，其执行只能一气呵成，不能中断。原语是由于关中断/开中断指令实现的。软件解决方案的主要问题是由于“进入区的各种操作无法一气呵成”，因此如果能把进入区，退出区的操作都是用“原语”实现，是这些操作能“一气呵成”就能避免问题。

一对原语：wait（S）和signal（S）原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个传入的一个参数。

wait(S)，signal(S)两个操作分别写为P(S)，V(S)

<br/>

信号量机制分类：

- 整型信号量
- 记录型信号量

<br/>

**整型信号量**

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。

Eg：某计算机系统中有一台打印机....

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys51.png" alt="image-20211202142459397" style="zoom: 67%;" />

<br/>

过程：当有进程进入时，就将 信号量-1，当信号量减到0一下后来的进程就处于等待状态，当一进程完成后，就将信号量+1。

<br/><br/>

**记录型信号量**

整型信号量的缺陷是存在忙等问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量

<br/>

![image-20211202151135769](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys53.png)

<br/>

过程：当有进程请求资源时，剩余资源数减1，当剩余资源数小于0时，就会将进程放入等待队列，当某进程退出时，先检查资源数是否小于0，若小于就再等待队列中找一个进程使用资源，自己退出。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys54.png" alt="image-20211202152108910" style="zoom:67%;" />

<br/>

在考研题目中wait(S)，signal(S)也可以记为P(S)，V(S)，这对原语可用于实现系统资源的“申请”和“释放”

S.value的初值表示系统中某种资源的数目。

对信号量S的的一次P操作意味着进程请求一个单位的该类资源，因此需要执行S.value<0时表示该类资源已分配完毕，因此进程应该调用block原语进行自我阻塞（当前运行的进程从运行态—> 阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。

对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行S.value++，表示资源数加1，若加1后仍然是S.value<=0。表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的的一个进程（被唤醒进程从阻塞态—>就绪态）

<br/><br/><br/><br/>

#### （5）用信号量机制实现互斥，同步，前驱关系

<br/>

步骤：

1）分析并发进程的关键活动，划定临界区

2）设置互斥访问信号量mutex

3）在临界区之前执行P(mutex)

4）在临界区之后执行V(mutex)

注意：

- 对不同的临界资源需要设置不同的互斥信号量
- P，V操作必须成对出现。



<br/>

##### ① 互斥

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys55.png" alt="image-20211202155019827" style="zoom:67%;" />

<br/><br/>

##### ② 同步

<br/>

用信号量实现进程同步：

1）分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作

2）设置同步信号量S，初始为0

3）在“前操作”之后执行V（S）

4）在“后操作”之前执行P（S）

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys56.png" alt="image-20211202161213416" style="zoom:67%;" />

<br/>

若先执行到V（S）操作，则S++后S=1。之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S--，S的值变回0，P2进程不会执行block原语，而是继续向下执行4。

若先执行到P(S)操作，由于S=0，S--后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++,使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。

<br/><br/>

##### ③ 前驱关系

<br/>

进程P1中有句代码S1，P2中有句代码S2....P3....P6中有句代码要求按如下顺序执行：

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys57.png" alt="image-20211202161508502" style="zoom:67%;" />

<br/><br/><br/><br/>

### 6.各种同步互斥问题

<br/>

解决步骤：

1）关系分析。找出题目中描述的各个进程，分析他们的互斥，同步关系

2）整理思路。根据各进程的操作流程确定P，V操作的大致顺序

3）设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量一般为1，同步信号量的初始值要看对应资源的初始值是多少）

注：

- 当缓冲区数目不为1时，在生产者和消费者之间要设置mutex=1实现互斥。
- 当缓冲区数目为1时，可以不使用mutex=1实现互斥，由于缓冲区只有1，消费者生产者问题中存在对缓冲区满时和不满时讨论的同步关系，这使得在即使进程切换，也必须由第一个执行的进程先执行完，这样就保证只有一个进程访问缓冲区。就比如：下方多生产者问题中，如果缓冲区只有1，就由plate保证了只有一个进程可以访问缓冲区。
- 分析同步中的一前一后，不能从单个进程来考虑，而是要将一系列类似的进程看作是一个事件。例如：多消费者问题中，不能只考虑父亲或儿子，而是要将父亲，母亲放入水果看作一个事件，将儿子，女儿拿走水果看作一个事件，这样看似复杂的多消费者问题也可以转化为类似的单消费者问题。

<br/>

#### （1）生产者和消费者

<br/>

问题：

系统中有一组生产者和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。

生产者，消费者共享一个初始为空，大小为n的缓冲区。

只有缓冲区没满时，生产者才能把产品放入缓冲区，若满则必须等待

只有缓冲区不空时，消费者才能取出产品，若空则必须等待

缓冲区是临界资源，访问时必须互斥。

<br/>

关系分析：

互斥：

- 生产者和消费者需要互斥的访问缓冲区，所以设置互斥信号量mutex=1

同步：

- 只有缓冲区不满时，才可以放入资源，若满时，需等待。初始时，设置缓冲区剩余数量为n，设置信号量full=n
- 只有缓冲区不空时，才可以取出产品，若为空，需等待。初始时，缓冲区中产品数为0，设置信号量empty=0

<br/>

伪代码展示：

```c
//设置信号量：
semaphore mutex=1;         //互斥信号量
semaphore full=n;          //缓冲区中剩余数量
semaphore empty=0;         //缓冲区中产品数

//消费者：
customer(){
   P(empty);              //消耗一个产品，如果没有就阻塞
   P(mutex);
   从缓冲区中取出一个产品
   V(mutex);
   V(full);               //释放一个缓冲区
}

//生产者
producer(){
    生产一个产品
    P(full);              //如果缓冲区剩余数量为空，就阻塞
    P(mutex);
    把产品放入缓冲区
    V(mutex);
    V(empty);             //产品数量加1
}
```

<br/><br/><br/><br/>

#### （2）多生产者和多消费者

<br/>

问题：

桌子上有一个盘子，每次只能向其中放入一种水果。

爸爸专门向其中放苹果，妈妈专门向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。

只有盘子为空时，爸妈才可以向盘子中放水果。只有盘子中有自己需要的水果时，儿子或女儿才从盘子中取出水果。

<br/>

关系分析：

互斥：

- 对盘子的访问要互斥的进行

同步：

- 父亲先放入苹果，女儿才能吃苹果。初始时，苹果数量为0，设置苹果数量信号量apple=0
- 母亲先放入橘子，儿子才能吃橘子。初始时，橘子数量为0，设置橘子数量信号量orange=0
- 只有父母放入水果在盘子后，子女才能吃水果。初始时，盘子中（缓冲区）的没有水果，盘子剩余空间为n，设置信号量plate=n

这里我们可以看作水果就是产品，盘子是缓冲区。只有盘子不满时，才可以放入水果；只有盘子不为空时，才可以拿走水果

<br/>

示意图：

plate  = n ，不是 1

<br/>

![image-20211209114538812](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys58.png)

<br/>

伪代码展示：

```c
//设置信号量
semaphore mutex=1;
semaphore apple=0;
semaphore orange=0;
semaphore plate=n;

//父亲进程
father(){
    准备一个苹果
    P(plate);           //消耗盘子中的1个位置，如果没有空间就等待
    P(mutex);
    放入一个苹果
    V(mutex);
    V(apple);           //盘子中多了一个苹果
}

//母亲进程
mother(){
    准备一个橘子
    P(plate);
    P(mutex);
    放入一个橘子
    V(mutex);
    V(apple);
}

//儿子进程
son(){
    P(orange);           //消耗1个橙子，如果没有就等待
    P(mutex);
    从盘子中拿出橘子
    V(mutex);
    V(plate);           //释放盘子中的一个空间
    吃掉橘子
}

//女儿进程
daughter(){
    P(apple);
    P(mutex);
    吃掉苹果
    V(mutex);
    V(plate);
    吃掉苹果
}
```

<br/><br/><br/><br/>

#### （3）吸烟者问题

<br/>

问题：

假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停的卷烟并抽掉它，但是要卷起一个眼需要三种材料：烟草，纸和胶水。

三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。

供应者进程无限供应这三种材料，供应者每次将两种材料放在桌子上，拥有剩下那种材料的抽烟者将桌子上的材料拿走并抽掉它，并给进程一个信号告诉完成了，供应者知道完成后就将另一个人要的材料放上，这个过程一直重复。（让三个者轮流抽烟）

<br/>

关系分析：

互斥：

- 供应商和抽烟者都要互斥的访问桌子

同步：

- 供应上放组合1，第一个人就拿走组合1，设置组合1的信号量offer1=0
- 供应上放组合2，第二个人就拿走组合2，设置组合1的信号量offer2=0
- 供应上放组合3，第三个人就拿走组合3，设置组合1的信号量offer3=0
- 抽烟者抽完烟后，提醒供应商将材料放在桌子上，设置信号量finish=0

注：这里就出现了一种新的情况，原先对生产者是没有消费者的反馈机制，所以需要对缓存区剩余空间进行设置，进而生产者知道什么时候可以生产，消费者什么时候可以消费。而出现反馈机制后，出现了反馈就说明缓存区有空间，没有反馈就说明缓冲区没有空间，由此已经起到了plate的作用，所以可以不用再写一个plate信号量。

<br/>

![image-20211209122211554](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys59.png)

<br/>

伪代码展示：

```c
//设置信号量
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
int i = 0;                //保证进程轮流执行

//供应者进程
privoder(){
    if(i==0){
        将组合1放在桌子上
        V(offer1)           //桌子上有组合1了
    }else if(i==1){
        将组合2放在桌子上
        V(offer2)
    }else if(i==2){
        将组合3放在桌子上
        V(offer3)
    }
    i = (i+1)%3
    P(finish);             //收到反馈才能继续生产，因为桌子只能放1个    
}

//抽烟者一进程
smoker1(){
    P(offer1);            //有组合1才能抽烟
    从桌子上拿走组合1，开始抽烟
    V(finish)             //反馈告诉供应商，桌子上的材料被拿走了，可以再放材料了
}

//抽烟者二进程
smoker2(){
    P(offer2);           
    从桌子上拿走组合2，开始抽烟
    V(finish)          
}

//抽烟者一进程
smoker3(){
    P(offer3);            
    从桌子上拿走组合3，开始抽烟
    V(finish)           
}
```

<br/><br/>

**一个新的问题**

<br/>

当桌子上可以放n个组合后（不需要轮流抽烟，有的话就可以抽）

解答：

这时就需要设置互斥量mutex=1，保证同一时间只有一个进程可以访问缓冲区，其他的可以不变。

原先finish最大为1，现在最大为n，只要finish不足n，就可以一直生产

<br/>

```c
//设置信号量
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
semaphore mutex=1;
int i = 0;                //保证进程轮流执行

//供应者进程
privoder(){
    if(i==0){
        P(mutex)
        将组合1放在桌子上
        V(mutex)
        V(offer1)           //桌子上有组合1了
    }else if(i==1){
        P(mutex)
        将组合2放在桌子上
        V(mutex)
        V(offer2)
    }else if(i==2){
        P(mutex)
        将组合3放在桌子上
        V(mutex)
        V(offer3)
    }
    i = (i+1)%3
    P(finish);             //收到反馈才能继续生产，因为桌子只能放1个    
}

//抽烟者一进程
smoker1(){
    P(offer1);            //有组合1才能抽烟
    P(mutex)
    从桌子上拿走组合1，开始抽烟
    V(mutex)
    V(finish)             //反馈告诉供应商，桌子上的材料被拿走了，可以再放材料了
}

//抽烟者二进程
smoker2(){
    P(offer2);   
    P(mutex)
    从桌子上拿走组合2，开始抽烟
    V(mutex)
    V(finish)          
}

//抽烟者一进程
smoker3(){
    P(offer3); 
    P(mutex)
    从桌子上拿走组合3，开始抽烟
    V(mutex)
    V(finish)           
}


```

<br/><br/><br/><br/>

#### （4）读者 - 写者问题

<br/>

问题：

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，单若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：

1）允许多个读进程同时对文件进行读操作

2）只允许一个写者往文件中写数据

3）任一写者在完成写操作之前不允许其他读者或写着工作

4）写者执行写操作前，应让已有的读者和写者全部退出

<br/>

关系分析：

互斥：

- 写者 — 读者
- 写者 — 写者

<br/>

设置信号量：

由于写者与其他进程都互斥，所以把其他进程当作一个事件，只用一个信号量rw=1，实现互斥

由于读者之间是不互斥的，所以设置一个count来表示目前有多少个读进程在访问，当count=0时，就是第一次访问时，要进行上锁，当最后一个读进程推出后，进行解锁。

为了保证count操作和上锁操作的一气呵成的，就需要设置信号量mutex对rw上锁和解锁分别进行上锁P(mutex)

因为在最后一个读进程退出后才能进行写操作，假如有源源不断地读操作来，就会让count一直进行加，那写操作就会“饿死”，所以需要设置信号量 w 对 rw 互斥的锁上在加一把锁，保证如果有读进程在写进程之后来，就把后来的读进程进行阻塞，阻止count++，来实现写进程优先

<br/>

伪代码展示：

```c
//设置信号量
semaphore rw=1;         //实现写进程与其他进程互斥
semaphore mutex=1;      //用于保证对count变量的互斥访问
semaphore w=1;          //用于实现写进程优先
int count=0;            //记录当前有几个读进程

//写进程
writer(){
    while(1){
        //进程获得进程的使用权，就可以利用P(w)对后面的进程进行阻塞，防止后面读进程一直让count++
        //给读写进程加一个相同的头部，就让读写进程地位相等，可以一起竞争
        P(w);         
        P(rw);
        写文件
        V(rw);
        V(w);
    }
}

//读进程
reader(){
    while(1){
        P(w);
        P(mute);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        读文件
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex);
    }
}
```

<br/><br/><br/><br/>

### 7.管程

<br/>

信号量机制存在的问题：编写程序困难，易出错

<br/>

定义：一种特殊的软件模块，有这些部分组成；

1）局部于管程的共享数据结构说明

2）对该数据结构进行操作的一组过程（就是函数）

3）对局部于管程的共享数据设置初始值的语句

4）管程有一个名字

<br/>

基本特征：

1）局部于管程的数据只能被局部于管程的过程访问

2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据

3）每次仅允许一个进程在管城内执行某个过程

4）如果一个过程出现wait或sleep等情况，视为已经退出管程

5）管程的互斥特性是由编译器负责实现的

<br/>

伪代码展示：

```c
monitor ProducerConsumer
  condition full,empty;  //empty:产品数量    full：缓冲区剩余数量
  ingt count=0;
 
  //生产产品
  void insert(Item item){  
    if(count==N)    
        wait(full);      //缓冲区剩余数量为0，要等待
    count++;
    insert_item(item);
    if(count==1)
        signal(empty);   //产品数量加1   
  }
  
  //消费产品
  Item remove(){
      if(count==0)     
          wait(empty);   //产品数量为0，要等待
      count--;
      if(count==N-1)
          singal(full)   //缓冲区剩余数量加1
      return remove_item();
  }
end monitor;


//生产者进程
producer(){
    while(1){
        item = 生产一个产品；
        ProducerConsumer.insert(item);
    }
}


//消费者进程
consumer(){
    while(1){
        item = ProducerConsumer.remove();
        消费产品item;
    }
}
```

<br/><br/><br/><br/>

### 8.死锁

<br/>

#### （1）基本概念

<br/>

死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象

饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。

死循环：某进程执行过程中一直跳不出来某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

<br/>

![image-20211210135747772](https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys61.png)

<br/><br/>

死锁产生的条件

产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。

互斥条件：只要对必须互斥使用的资源的争抢才会导致死锁（如：哲学家的筷子，打印机设备）

不剥夺条件：进程所获得资源在未使用完之前，不能由其他进程夺走，只能主动释放

请求和保持条件：进程已经有一定资源了，仍在请求其他资源，但其他资源又被其他进程所占用，此时请求的进程阻塞，但又对自己有的资源不放

循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程以已获得的资源同时被下一个进程所请求

<br/>

注：

- 发生死锁时一定有循环等待，但是发生循环等待时未必死锁。
- 如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了

<br/><br/>

发生的情况：

1）对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。

2）进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。比如：进程A占用资源1，进程B占用资源2，而此时进程A请求资源2，进程B请求资源1，形成死锁。

3）信号量的使用不当也会造成死锁。如：生产者-消费者问题中，如果把实现互斥的P操作在实现同步的P操作之前，就可能导致死锁

总之，对不可剥夺资源的不合理分配，可能导致死锁。

<br/><br/><br/><br/>

#### （2）预防死锁

<br/>

1）破环互斥条件

<br/>

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术

操作系统可以采用SPOOLing技术把独占设备在逻辑上改为共享的设备。比如：用SPOOLing技术将打印机改造为共享设备

<br/>

该策略的缺点：

并不是所有设备都可以改造成可以共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥性。

<br/><br/>

2）破环不剥夺条件

<br/>

方案一：

当某个进程请求新资源得不到满足时，他必须立刻释放所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也主动释放。

方案二：

当某个进程需要的资源被其他进程占有时，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般要考虑优先级

<br/>

缺点：

- 实现起来比较复杂
- 释放已获得资源可能造成前一阶段工作的失效。因此此方法一般只适用于易于保存和恢复状态的资源
- 反复的申请和释放资源会造成系统开销，降低系统吞吐量
- 若采用方案一，意味着只要暂时得不到某个资源，之前获得的资源就都需要放弃，以后再重新申请。如果一直发生这种情况会导致饥饿

<br/><br/>

3）破环请求和保持条件

<br/>

可以使用静态分配方法，即进程在运行前一次性申请完所需的全部资源，在他的资源未满足之前，不让它投入运行。一旦投入运行，这些资源就一直归他所有，该进程就不会请求别的任何资源

<br/>

缺点：

有些资源可能只需运行很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的浪费，资源利用率低。另外，会导致某些进程饥饿

<br/><br/>

4）破环循环等待条件

<br/>

可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次性申请完。

原理分析：一个进程只有占用小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地申请小编号地资源，从而就不会产生循环等待地现象。并且在任意时刻，总有一个进程拥有地资源编号最大，那这个进程申请之后地资源必然是畅通无阻。因此不可能出现所有进程都阻塞地现象

<br/>

缺点：

- 不方便增加新的设备，因为可能需要重新分配所有编号
- 进程实际使用资源地顺序肯和编号递增顺序不一致，会导致资源的浪费
- 必须按规定次序申请资源，用户变成麻烦

<br/><br/><br/><br/>

#### （3）避免死锁

<br/>

##### ① 安全序列

<br/>

安全序列：指如果系统按照这种顺序分配资源，则每个进程都能顺序完成。只要找出一个安全序列，系统就是安全的，当然，安全序列可以有多个

如果分配资源后系统找不到任何一个安全序列，系统就进入了不安全状态。这意味之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。

注：

- 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态下时未必已经发生了死锁，但发生死锁一定处于不安全状态）
- 可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源的分配请求

<br/><br/>

问题：

你是一位银行家，手里有100亿资金

有三位企业家找你借款，分别是企业家B，企业家A，企业家T

B最多借70亿，A最多借40亿，T最多借50亿

然而，江湖有一个不成文的规矩，如果借给企业家的钱达不到最大需求，那么不管之前借了多少都不用还

那么你要怎么借钱给他们？

<br/>

刚开始，BAT三位企业家分别借了20，10，30亿。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys62.png" alt="image-20211210184207309" style="zoom:67%;" />

<br/>

为了保证最后都能还，你要继续怎么借钱呢？

分析：其实借钱的过程就是寻找安全序列的过程，分清楚什么时候借钱不会导致不安全，这样就可以借。

例如：

1）假如B再借30亿，那你手上只会有10亿，接下来谁找你借钱，你都借不了，就出现了不安全序列，那着30亿就不能借。

2）假如A再借20亿，那你手上还有20亿，这是再借给A10亿后，A就会将借的钱都还回来，这样再借T，等T还回来再借B，就全部都可以还回，那这就是一个安全序列。

<br/><br/>

##### ② 安全性算法

<br/>

检查当前剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收

不断重复这个过程，看是否能将所有进程都加入安全序列

<br/><br/>

##### ③ 银行家算法

<br/>

核心思想：在进程提出资源请求时，先预判此次分配是否会导致系统进入不安全状态。如果会，就按时不答应这个请求，让该进程阻塞等待。

<br/>

在上述题中，只有一种资源，如果是多种，该怎么分配呢？

假设系统中有n个进程，m种资源

<br/>

最大需求矩阵Max：每个进程在运行前，先声明对各种资源的最大需求数，则可用一个n*m的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数，M[ i , j ] = k，表示进程Pi最多需要K个资源。

分配矩阵Allocation：系统可以用一个m*n的矩阵表示对所有进程的资源分配情况。

Need矩阵：表示各进程还最多需要多少各种资源。就是Max - Allocatuion

另外，

可以用一个长度为m的一维数组Available表示当前进程还有多少可用资源

可以用一个长度为m的一位数组Request表示本次申请的各种资源数量。

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys63.png" alt="image-20211210190616471" style="zoom: 67%;" />

<br/>

算法步骤：

当有需求进入时：

1）如果第 i 个进程请求资源数小于或等于于对应进程最大的需要资源，就进入步骤 2）；否则认为出错

2）再看请求资源数是都小于或等于可用资源，如果可用资源足够，就进入步骤 3）；否则表示尚未足够资源，进程需等待

3）系统试着把资源分配给进程 i ，并修改对应的数据（此时并不是真的分配，而是将数值进行计算，看能不能找到安全序列）

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys64.png" alt="image-20211210193115505" style="zoom: 80%;" />

<br/>

4）操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态，处于就正式分配；否则，恢复相应数据，让进程阻塞等待

<br/><br/><br/><br/>

#### （4）检测和解除

<br/>

##### ① 检测

<br/>

为了能对系统是否发生死锁进行检测，必须：

1）用某种数据结构来保存资源的请求和分配信息

2）提供一种算法，利用上述信息来检测系统是否进入死锁状态

<br/>

数据结构（资源分配图）：

两种结点：

- 进程结点：对应一个进程
- 资源结点：对应一类资源，一类资源可以有多个

两条边：

- 进程结点 —>  资源结点：表示进程想申请几个资源（每条边代表一个）
- 资源结点 —>  进程结点：表示已经为进程分配了几个资源（每条边代表一个）

<br/>

<img src="https://cdn.jsdelivr.net/gh/hemeilun/picture/opersys65.png" alt="image-20211211163413348" style="zoom:80%;" />

<br/>

死锁检测分析：

1）如果系统中剩余的资源数足够满足进程的需求，那么这个进程暂时是不会阻塞，可以顺利的执行下去。

2）如果这个进程执行结束将资源归还给系统，就可能是某些正在等待资源的进程被激活，并顺利的执行下去。

3）相应的，这些被激活的进程执行完后又会归还一些资源再激活另一些资源并激活另一些阻塞的进程

如果按照上述过程分析，最终能消除所有边，就称这个图是 **完全可简化的**。此时一定没有死锁（相当于找到一个安全序列）；如果不能消除所有边，那么此时就是发生了死锁，最终连着边的就是死锁的进程。

<br/><br/>

检查死锁的算法：

1）在资源分配图中，找出既不阻塞又不孤立的进程Pi，分配给它所需的所有资源（即找出有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立结点。

2）进程Pi释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来阻塞的进程变为非阻塞。再继续执行1）操作，直到消除所有的边，则称改图是可简化的。

死锁定理：如果某时刻系统的资源分配图是不可简化的，那么此时系统死锁。

<br/><br/><br/>

##### ② 解除

<br/>

解除的方法有：

资源剥夺法：挂起（暂时放在外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

撤销进程法（或称终止进程法）：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这些方式的优点是实现简单，但所付出的代价会很大。因为有些进程已经运行很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还要重头再来。

进程回退法：让一个或多个进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

<br/><br/><br/><br/><br/><br/><br/>



